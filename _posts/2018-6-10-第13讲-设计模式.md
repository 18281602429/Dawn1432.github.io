---
layout: post
title: 设计模式
date: 2018-6-10
tags: Java核心技术36讲笔记
---

### 什么是设计模式
- 设计模式是人们为软件开发中相同表征的问题，抽象出的可重复利用的解决方案。在某种程度上，设计模式已经代表了一些特定情况的最佳实践，同时也起到了软件工程师之间沟通的“行话”的作用。理解和掌握典型的设计模式，有利于我们提高沟通、设计的效率和质量。

### 常见的设计模式有哪些
- 创建型模式，是对对象创建过程的各种问题和解决方案的总结
    - 工厂类
        - 简单工厂模式
                工厂对象根据客户传入的参数决定创建出哪一种产品类的实例
        - 工厂模式(Factory)
                工厂模式是最常用的实例化对象模式，是用工厂方法代替new操作的一种模式，根据客户传入的参数决定具体创建哪个类对象实例
        - 抽象工厂模式(Abstract Factory)
                抽象工厂模式就是在工厂模式的基础之上，把工厂类给抽离成一个抽象类，以适应更复杂的对象创建场景
    - 单例模式(Singleton)
            客户获得的对象实例永远是同一个实例对象
	- 原型模式(Prototype)
			通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节
    - 创建者模式(Builder)
            将一个“复杂对象的构建算法”与它的“部件及组装方式”分离，使得构件算法和组装方式可以独立应对变化

- 结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验
	- 桥梁模式(Bridge)
        - 桥梁模式，会经常使用到抽象类或者接口来完成抽象的过程
        - 白话说，就是将抽象部分与实现部分分离，使它们都可以独立的变化
	- 装饰模式(Decorator)
        - 装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。例如,java的io部分有抽象类InputStream，针对不同的角度java官方提供了不同的子类FileInputStream，ByteInputStream
        - 装饰模式是通过创建一个包装对象，也就是装饰来包裹真实的对象
	- 适配器模式(Adapter)
        - 适配器模式将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起
        - 简单来说就是当用户想要使用一个接口时，发现参数或者返回类型不同而无法使用时，使用创建一个类去包装这个接口，创建的类中新建方法传入用户想要的参数并返回用户想要的返回类型，在类中去完成接口与用户需求之间的适配工作。
    - 装饰模式和适配器模式的区别说明：书店里卖道德经，有线装版、精装版，也有日文版、英文版。线装版和精装版就是装饰模式，而日文版和英文版就是适配器模式
	- 代理模式(Proxy)
        - 包含三个角色：抽象角色、代理角色、真实角色，代理角色调用抽象角色的方法，方法的实现由真实角色完成
        - 为其他对象提供一种代理以控制对这个对象的访问
        - 在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用
    - 门面(外观)模式(Facade)
        - 门面模式，是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口
        - 将各个不同的方法，组装到一起，然后客户通过调用这个大的方法完成想完成的操作
	- 享元模式(Flyweight)

- 行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。
	- 策略模式(Strategy)
        - 包含三个角色：抽象策略角色、具体策略角色、环境角色，环境角色中持有一个抽象策略类的引用，某处实例化一个环境角色时传递了一个具体策略角色到环境角色中，通过环境角色调用抽象策略角色的方法完成工作，而抽象角色的方法由具体策略角色去实现完成，实际上调用的是具体策略角色的方法
        - 策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换
    - 观察者模式(Observer)
        - 包含两个角色，观察者和被观察者，一旦被观察者发生变化，观察者就做出相应的响应
        - 观察者和被观察对象之间的互动关系不能体现成类之间的直接调用，这样耦合起来的关系并不是真正的观察者模式
	- 责任链模式
        - 很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
        - 发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任
	- 双亲委派模式
        - 有事先交给父类或者父类的父类去做，如果一直到最顶层父类都找不到方法，就当前类去做
	- 解释器模式(Interpreter)
	- 命令模式(Command)
	- 迭代器模式(Iterator)
	- 模板方法模式(Template Method)
	- 访问者模式(Visitor)

### spring中的设计模式
- 创建Bean的过程中默认使用单例模式，通过配置可以使用原型模式（prototype）
- BeanFactory和ApplicationContext应用了工厂模式
- spring 实现aop则分别用到了代理模式、装饰器模式、适配器模式等
- 事件监听器，则是观察者模式
- spring中集成的JdbcTemplate则是模板模式

### 单例模式
- 懒汉式
```java
public class Singleton {
    private Singleton() {
    }
    private static Singleton single = null;
    public static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
```

- 饿汉式
```java
public class Singleton {
    private Singleton() {
    }
    private static Singleton single = new Singleton();
    public static Singleton getInstance() {
        return single;
    }
}
```

- `java.lang.Runtime`则是java源码中典型的单例模式应用，采用饿汉式初始化。
```java
public class Runtime {
        private static Runtime currentRuntime = new Runtime();

        public static Runtime getRuntime() {
            return currentRuntime;
        }

        /** Don't let anyone else instantiate this class */
        private Runtime() {}
        ...
}
```

- 单例模式，无论是懒汉式还是饿汉式，都应当将类的构造函数设为private的，以防止类被意外实例化。
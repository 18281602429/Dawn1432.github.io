---
layout: post
title: Java的文件拷贝方式
date: 2018-5-29
tags: Java核心技术36讲笔记
---

### Java的文件拷贝方式
- 利用java.io，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作
	- java.io
    ```java
    public static void copyFileByStream(File source, File dest) throws IOException {
        try (InputStream is = new FileInputStream(source);
            OutputStream os = new FileOutputStream(dest);){
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) > 0) {
                os.write(buffer, 0, length);
            }
        }
    }
    ```
    - java.nio
    ```java
    public static void copyFileByChannel(File source, File dest) throws IOException {
        try (FileChannel sourceChannel = new FileInputStream(source).getChannel();
             FileChannel targetChannel = new FileOutputStream(dest).getChannel();){
            for (long count = sourceChannel.size() ;count>0 ;) {
                long transferred = sourceChannel.transferTo(
                        sourceChannel.position(), count, targetChannel);
                        sourceChannel.position(sourceChannel.position() + transferred);
                count -= transferred;
            }
        }
     }
    ```
- 利用Java 标准类库提供的Files.copy来实现
  Java的nio包下面还提供了一个final类：`java.nio.file.Files`，该类提供了三个同名的静态工具方法来实现文件拷贝，其中两个工具方法在将参数进行转换之后最终又调用了同名的一个私有方法来实现文件拷贝，它们分别是：
```java
public static Path copy(Path source, Path target, CopyOption... options)  throws IOException {
    FileSystemProvider provider = provider(source);
    if (provider(target) == provider) {
        provider.copy(source, target, options);
    } else {
        CopyMoveHelper.copyToForeignTarget(source, target, options);
    }
    return target;
}
public static long copy(Path source, OutputStream out) throws IOException {...}
public static long copy(InputStream in, Path target, CopyOption... options) throws IOException {...}
private static long copy(InputStream source, OutputStream sink) throws IOException {
	long nread = 0L;
    byte[] buf = new byte[BUFFER_SIZE];
    int n;
    while ((n = source.read(buf)) > 0) {
        sink.write(buf, 0, n);
        nread += n;
    }
    return nread;
}
```
  仔细观察Files真正的文件拷贝其实只有两种实现方式，而仔细比对这个私有拷贝方法的实现方式会发现，它和java.io实现的文件拷贝是一模一样的

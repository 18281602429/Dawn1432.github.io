---
layout: post
title: Java内存区域
date: 2018-5-14
tags: 《深入理解Java虚拟机》看书笔记
---

## Java内存区域

#### 运行时数据区域（Java SE 7版）
- 程序计数器
- 方法栈
	- 虚拟机栈
	- 本地方法栈
- 堆
- 方法区

#### 程序计数器
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个程序计数器来完成；
- 每个线程都有自己的独立程序计数器（线程私有内存）;
- 如果程序正在执行的是java方法，计数器的纪录就是正在执行的虚拟机字节码指令的地址；
- 如果正在执行的是Native方法，则这个计数器的纪录为空；
- 此区域没有规定任何`OutOfMemoryError`;

#### Java虚拟机栈
- Java虚拟机栈是线程私有的，生命周期与线程一致；
- 每个方法执行的同时都会创建一个栈帧用于存储：
	- 局部变量表
		- 局部变量表存放了编译期可知的各种基本数据类型和对象引用类型：
			- 基本类型
				1. boolean
            	2. byte
            	3. char
            	4. short
            	5. int
            	6. float
            	7. long（64位，占用两个局部变量空间）
            	8. double（64位，占用两个局部变量空间）
            - 对象引用类型
            	1. 可能是一个指向对象起始地址的指针
            	2. 也可能是指向一个代表对象的句柄
            	3. 或者其他和这个对象相关的地址
            - returnAddress类型
            	1. 指向一条字节码指令的地址
    	- 局部变量表所需要的内存空间在编译期就完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全可以确定的，方法运行期间无法改变局部变量表的大小;
	- 操作数栈
	- 动态链接
	- 方法出口等信息
- 方法的调用到执行完毕，就是栈帧在虚拟机栈中入栈到出栈的过程；
- 如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError;
- 如果虚拟机允许动态扩展，扩展时无法申请到足够的内存就会抛出OutOfMemoryError

#### 本地方法栈
- 与Java虚拟机栈作用相似：
	- Java虚拟机栈为虚拟机执行Java方法（字节码）服务
	- 本地方法栈为Native方法服务
	- 不同的虚拟机对Java虚拟机栈与本地方法栈的实现不同
	- 本地方法栈也会抛出StackOverflowError和OutOfMemoryError

#### Java堆
- 所有线程共享这一区域
- 几乎所有对象实例都在这里分配内存，存放所有的对象实例
- 所有的对象实例和数组都在堆上分配
- 由于JIT编译器的发展，所有对象都在堆上分配这一定律不再是绝对的
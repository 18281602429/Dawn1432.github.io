---
layout: post
title: JAVA多线程常见问题总结
date: 2018-01-16
tags: 博客
---

##什么是多线程？
> 多线程（英语：Multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。
>                                                     —— 维基百科 多线程

##多线程有什么用？
- 发挥多核CPU的优势
随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程“同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

- 防止阻塞
从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。

- 便于建模
这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

##创建线程的方式
- 继承Thread类
定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务，因此把run()方法称为执行体，然后实例化该类并使用start()方法来启动线程。
```
public class MyThread extends Thread {
    @Override
    public void run() {
        //do something
    }
}
```

- 实现Runnable接口
定义runnable接口的实现类，并实现该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。实例化该实现类后，作为参数传递到一个Thread类中，然后start()。通常人们使用较为简单的写法，即:
```
new Thread(new Runnable() {
            public void run() {
                //do something
            }
        }).start();
```

- 通过Callable和Future创建线程
定义Callable接口的实现类，并实现接口的call()方法，该call()方法将作为线程执行体，并且有返回值。创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。使用FutureTask对象作为Thread对象的target创建并启动新线程。调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
```
new Thread(new FutureTask<Object>(new Callable<Object>() {
            public Object call() throws Exception {
                //do something
                return new Object();
            }
        })).start();
```

以上是常见的三种创建线程的方式，因为实现接口的方式比继承类的方式更灵活，也能减少代码之间的耦合度，面向接口编程也是设计模式6大原则的核心，所以第二种方式被广泛的使用。

##start()方法和run()方法的区别
基于上一部分的内容，我们可以知道strart()方法是线程类的启动方法，而run()方法常见于继承Thread类或实现了Runnable接口的类，是线程类的执行体。对于一个线程类：
```
public class MyThread extends Thread {
    @Override
    public void run() {
        //do something
    }
}
```
实例化并调用start方法，意味着main线程启动了一个子线程，继而会执行run方法中的内容。实例化并调用run方法，就相对简单，它会执行run方法中的内容，仅仅是因为对象调用了该方法，没有其他附加含义。
```
public static void main(String[] args) {
        new MyThread().start();
        new MyThread().run();
    }
```

##Runnable接口和Callable接口的区别
- Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已。
- Callable接口中的call()方法是有返回值的，是一个泛型，需要和Future、FutureTask配合可以用来获取异步执行的结果。

这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已，而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务。

##sleep方法和wait方法有什么区别
- sleep是Thread的方法，可包含一个或两个参数。wait是Object类的方法可包含无参、一个参数、两个参数。
- sleep方法和wait方法都可以用来使线程放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。
- sleep方法时间到，线程处于临时阻塞状态或者运行状态。wait方法如果没有被设置时间，就必须要通过notify或者notifyAll来唤醒。
- sleep方法可以在任何地方使用(使用范围)，wait方法只能在同步控制方法或者同步控制块里面使用，因为wait方法是通知当前线程等待并释放对象锁，与nofity方法的通知对象并获得锁是成对的，如果没有获得对象锁则没办法对对象锁进行操作则wait无意义。
- sleep必须捕获异常，因为在sleep过程中有可能被调用interrupt打断从而抛出InterruptException如果不捕获异常则线程面临异常中断的可能。而wait不需要捕获异常。

##什么是线程安全
通俗的说，如果代码在单线程和多线程下执行的结果永远保持一致，则我们称这段代码是线程安全的。线程安全有几个级别：
- 不可变
像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用。

- 绝对线程安全
不管运行时环境如何，调用者都不需要额外的同步措施，要做到这一点通常需要付出许多额外的性能代价。Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet

- 相对线程安全
相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。【注：fail-fast机制，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。】

- 线程非安全
就是通常说的，程序在多线程和单线程的情况下，执行结果不一致的情况。JAVA中ArrayList、LinkedList、HashMap等都是线程非安全的类。

##volatile关键字的作用
- 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据

- 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互。现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。

从实践角度而言，volatile的一个重要作用就是和乐观锁技术结合，保证原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。

##ThreadLocal有什么用
简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开放地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题。

##CyclicBarrier和CountDownLatch的区别
两个看上去有点像的类，都在java.util.concurrent下的同步辅助类，都可以用来表示代码运行到某个点上。JDK6文档中纪录如下：

>public class java.util.concurrent.CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。

>public class java.util.concurrent.CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 

二者的区别在于：
- CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行

- CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务

- CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了
---
layout: post
title: 常见算法收集
date: 2018-03-09
tags: 博客
---

## 排序类
#### 快速排序
时间复杂度：O(N*logN)

基本思路：
- 从待排序的数列中选一个数作为key值(通常选第一个)；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边(从小到大排序)；
- 对被key分割出来的左右两个小数列重复第二步(递归)，直至各区间只有1个数；

```java
private void quickSort(int[] a, int low, int high) {
		int l = low;
		int h = high;
		int key = a[low];
		while (l < h) {
			while (l < h && a[h] > key) {
				h--;
			}
			if (l < h) {
				int temp = a[l];
				a[l] = a[h];
				a[h] = temp;
				l++;
			}
			while (l < h && a[l] < key) {
				l++;
			}
			if (l < h) {
				int temp = a[h];
				a[h] = a[l];
				a[l] = temp;
			}
		}
		if (low < l) {
			quickSort(a, low, l - 1);
		}
		if (h < high) {
			quickSort(a, h + 1, high);
		}
	}
```

#### 冒泡排序
时间复杂度：O(n2)

基本思想：两个数比较大小，较大的数下沉，较小的数向上浮动。

实现步骤：
- 从第一个数字开始，比较其和后一个数字的大小
- 如果第一个数字大，则交换位置，否则什么也不做
- 循环直到最后一个数字，至此，整个数组中最大的数字在最后一个
- 又从第一个数字开始，相邻间数字比较，大的数字向后挪动
- 此次循环只比较到倒数第二个数字，因为最后一个数字上一轮循环已经证明是最大的
- 如此循环比较相邻数字，直至某轮循环没有发生任何比较，则认为此数组已经有序

```java
private void myBubbleSort(int[] a) {
        boolean flag = true;
        int size = a.length;
        while (flag) {
            flag = false;
            for (int i = 0;i < size-1;i++) {
                if (a[i] > a[i+1]) {
                    int temp = a[i];
                    a[i] = a[i+1];
                    a[i+1] = temp;
                    flag = true;
                }
            }
            size -= 1;
        }
    }
```

#### 归并排序
时间复杂度：O(N*logN)

基本思路：将数组分割成单个数据的数列，然后合并相邻的数列

实现步骤：
- 比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1
- 否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1
- 如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元

```java

```

#### 选择排序
时间复杂度：O(n2)


#### 插入排序
时间复杂度：O(n2)


#### 希尔排序
时间复杂度：O(n1.5)


#### 堆排序
时间复杂度：O(N*logN)

#### 基数排序
时间复杂度：O(d(n+r))


## 其他类
#### 筛选法找质数



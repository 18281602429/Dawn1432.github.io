---
layout: post
title: 常见算法收集
date: 2018-03-09
tags: 博客
---

## 排序类
#### 快速排序
时间复杂度：O(N*logN)

基本思路：
- 从待排序的数列中选一个数作为key值(通常选第一个)；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边(从小到大排序)；
- 对被key分割出来的左右两个小数列重复第二步(递归)，直至各区间只有1个数；

```java
private void quickSort(int[] a, int low, int high) {
		int l = low;
		int h = high;
		int key = a[low];
		while (l < h) {
			while (l < h && a[h] > key) {
				h--;
			}
			if (l < h) {
				int temp = a[l];
				a[l] = a[h];
				a[h] = temp;
				l++;
			}
			while (l < h && a[l] < key) {
				l++;
			}
			if (l < h) {
				int temp = a[h];
				a[h] = a[l];
				a[l] = temp;
			}
		}
		if (low < l) {
			quickSort(a, low, l - 1);
		}
		if (h < high) {
			quickSort(a, h + 1, high);
		}
	}
```

#### 冒泡排序
时间复杂度：O(n2)

基本思想：两个数比较大小，较大的数下沉，较小的数向上浮动。

实现步骤：
- 从第一个数字开始，比较其和后一个数字的大小
- 如果第一个数字大，则交换位置，否则什么也不做
- 循环直到最后一个数字，至此，整个数组中最大的数字在最后一个
- 又从第一个数字开始，相邻间数字比较，大的数字向后挪动
- 此次循环只比较到倒数第二个数字，因为最后一个数字上一轮循环已经证明是最大的
- 如此循环比较相邻数字，直至某轮循环没有发生任何比较，则认为此数组已经有序

```java
private void myBubbleSort(int[] a) {
        boolean flag = true;
        int size = a.length;
        while (flag) {
            flag = false;
            for (int i = 0;i < size-1;i++) {
                if (a[i] > a[i+1]) {
                    int temp = a[i];
                    a[i] = a[i+1];
                    a[i+1] = temp;
                    flag = true;
                }
            }
            size -= 1;
        }
    }
```

#### 归并排序
时间复杂度：O(N*logN)

基本思路：将数组分割成单个数据的数列，然后合并相邻的数列

实现步骤：
- 将数组拆分为两部分，分别对着两部分再进行拆分，直到不能再拆分(最后只剩一个数)
- 数组被拆分为两部分后，继而进行合并两个部分，两部分合并后在上一层级继续合并
- 所有被拆分的又被重新组合为一个数列

```java

    /**
     * 先拆分数组并排序，然后再合并
     * @param a 待分组排序的大数组
     * @param low 小数列的起始位置
     * @param high 小数列的结束位置（包含在数组内）
     */
    private static void mergeSort(int[] a, int low, int high) {
        //将数列分为两部分
        int mid = (low + high) / 2;
        if (low < high) {
            //左边部分进行拆分并排序
            mergeSort(a, low, mid);
            //右边部分进行拆分并排序
            mergeSort(a, mid + 1, high);
            //将已经有序的两部分进行合并
            merge(a, low, mid, high);
        }
    }

    /**
     * 合并有序数组
     * @param a 在各个小区域有序的数组
     * @param low 小数列在大数组中的开始位置
     * @param mid 两个有序小数列的中点位置
     * @param high 小数列在大数组中的结束位置
     */
    private static void merge(int[] a, int low, int mid, int high) {
        int[] temp = new int[high - low + 1];
        int i = low;
        int j = mid + 1;
        int k = 0;

        while (i <= mid && j <= high) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = a[i++];
        }

        while (j <= high) {
            temp[k++] = a[j++];
        }

        System.arraycopy(temp, 0, a, low, temp.length);
    }

```

#### 选择排序
时间复杂度：O(n2)


#### 插入排序
时间复杂度：O(n2)


#### 希尔排序
时间复杂度：O(n1.5)


#### 堆排序
时间复杂度：O(N*logN)

#### 基数排序
时间复杂度：O(d(n+r))


## 其他类
#### 筛选法找质数



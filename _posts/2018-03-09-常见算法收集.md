---
layout: post
title: 常见算法收集
date: 2018-03-09
tags: 博客
---

## 排序类
#### 快速排序
时间复杂度：O(N*logN)

基本思路：
- 从待排序的数列中选一个数作为key值(通常选第一个)；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边(从小到大排序)；
- 对被key分割出来的左右两个小数列重复第二步(递归)，直至各区间只有1个数；

```java
private void quickSort(int[] a, int low, int high) {
		int l = low;
		int h = high;
		int key = a[low];
		while (l < h) {
			while (l < h && a[h] > key) {
				h--;
			}
			if (l < h) {
				int temp = a[l];
				a[l] = a[h];
				a[h] = temp;
				l++;
			}
			while (l < h && a[l] < key) {
				l++;
			}
			if (l < h) {
				int temp = a[h];
				a[h] = a[l];
				a[l] = temp;
			}
		}
		if (low < l) {
			quickSort(a, low, l - 1);
		}
		if (h < high) {
			quickSort(a, h + 1, high);
		}
	}
```

#### 冒泡排序
时间复杂度：O(n2)

基本思想：两个数比较大小，较大的数下沉，较小的数向上浮动。

实现步骤：
- 从第一个数字开始，比较其和后一个数字的大小
- 如果第一个数字大，则交换位置，否则什么也不做
- 循环直到最后一个数字，至此，整个数组中最大的数字在最后一个
- 又从第一个数字开始，相邻间数字比较，大的数字向后挪动
- 此次循环只比较到倒数第二个数字，因为最后一个数字上一轮循环已经证明是最大的
- 如此循环比较相邻数字，直至某轮循环没有发生任何比较，则认为此数组已经有序

```java
private void myBubbleSort(int[] a) {
        boolean flag = true;
        int size = a.length;
        while (flag) {
            flag = false;
            for (int i = 0;i < size-1;i++) {
                if (a[i] > a[i+1]) {
                    int temp = a[i];
                    a[i] = a[i+1];
                    a[i+1] = temp;
                    flag = true;
                }
            }
            size -= 1;
        }
    }
```

#### 归并排序
时间复杂度：O(N*logN)

基本思路：将数组分割成单个数据的数列并将其视作有序数列，然后合并相邻的有序数列，直至所有数全部重组为一个数组

实现步骤：
- 将数组拆分为两部分，分别对着两部分再进行拆分，直到不能再拆分(最后只剩一个数)
- 数组被拆分为两部分后，继而进行合并两个部分，两部分合并后在上一层级继续合并
- 所有被拆分的又被重新组合为一个数列

```java

    /**
     * 先拆分数组并排序，然后再合并
     * @param a 待分组排序的大数组
     * @param low 小数列的起始位置
     * @param high 小数列的结束位置（包含在数组内）
     */
    private static void mergeSort(int[] a, int low, int high) {
        //将数列分为两部分
        int mid = (low + high) / 2;
        if (low < high) {
            //左边部分进行拆分并排序
            mergeSort(a, low, mid);
            //右边部分进行拆分并排序
            mergeSort(a, mid + 1, high);
            //将已经有序的两部分进行合并
            merge(a, low, mid, high);
        }
    }

    /**
     * 合并有序数组
     * @param a 在各个小区域有序的数组
     * @param low 小数列在大数组中的开始位置
     * @param mid 两个有序小数列的中点位置
     * @param high 小数列在大数组中的结束位置
     */
    private static void merge(int[] a, int low, int mid, int high) {
        int[] temp = new int[high - low + 1];
        int i = low;
        int j = mid + 1;
        int k = 0;

        while (i <= mid && j <= high) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = a[i++];
        }

        while (j <= high) {
            temp[k++] = a[j++];
        }

        System.arraycopy(temp, 0, a, low, temp.length);
    }
```

#### 选择排序
时间复杂度：O(n2)

选择排序分为三种它们的基本思路都一样，分别是：
- 简单选择排序
- 树形选择排序
- 堆排序

基本思路：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

实现步骤：
- 从左至右开始遍历数组，记录数字下标，并和右边的所有数字比较，如果右边数字小，则记录其下标
- 一趟遍历结束，如果下标和最开始记录的一致，则不做操作，反之则交换值
- 遍历完整个数组，数组变为有序

```java
    /**
     * 简单选择排序
     * @param a 待排序的数组
     */
    private static void selectSort(int[] a) {
        for (int i=0;i < a.length;i++) {
            //从左至右开始，假设最左边的为最小数
            int minIndex = i;
            for (int j = i+1;j<a.length;j++) {
                //用最左边的数与后面的数挨个比较，如果发现比它小的就纪录下标
                if (a[j] < a[minIndex]) {
                    minIndex = j;
                }
            }
            //一遍遍历结束后，如果最小的坐标不是之前赋值的，则做交换值操作
            if (minIndex != i) {
                int temp = a[i];
                a[i] = a[minIndex];
                a[minIndex] = temp;
            }
        }
    }
```

#### 插入排序
时间复杂度：O(n2)

基本思路：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。

实现步骤：
- 判断数组是否为空或大小小于1，如果是则不用排序
- 将数组的左侧作为有序数列（最开始只包含一个数字），右侧作为无序数列（最开始包含除左起第一个数字外的整个数列），从下表为1的数字开始遍历
- 用当前遍历的数字和左边的有序数列开始比较，并将其放到合适位置（遍历左边的有序数列，从右直左）
- 遍历完无序数列，无序数列变为0，有序数列包含整个数组

```java
private static void insertSort(int[] arr) {
        //如果数组为空或小于2，则不用排序
        if (arr == null || arr.length < 2) {
            return;
        }
        //从左起第二个数字开始遍历，左边为有序数列，右边为无序数列
        for (int i = 1; i < arr.length; i++) {
            //下标为i的数字和左边的有序数列进行比较
            for (int j = i; j > 0; j--) {
                //当下标为i的数字小于有序数列的数字时交换位置
                // 直到其在一个合适的位置
                //如果下标为i的数字大于有序数列右边第一个数字则不作任何操作
                // 因为左边是有序数列，所以它一定是大于左边所有数字的
                if (arr[j] < arr[j - 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                } else {
                    break;
                }
            }
        }
    }
```


#### 希尔排序
时间复杂度：O(n1.5)


#### 堆排序
时间复杂度：O(N*logN)

#### 基数排序
时间复杂度：O(d(n+r))


## 其他类
#### 筛选法找质数



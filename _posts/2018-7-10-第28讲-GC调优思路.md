---
layout: post
title: GC调优思路
date: 2018-7-10
tags: Java核心技术36讲笔记
---

### 谈谈GC调优的思路
- 对于调优，这一定是针对特定场景、特定目的的事情，对于GC调优来说，首先就需要清楚调优的目标是什么。从性能的角度看，通常关注三个方面，内存占用footprint、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他GC相关的场景，例如，OOM也可能与不合理的GC相关参数有关；或者，应用启动速度方面的需求，GC也会是个考虑的方面。
- 基本的调优思路可以总结为：
	- 理解应用需求和问题，确定调优的目标。假设，开发的是一个应用服务，但发现偶尔会出现性能抖动，出现较长时间的服务停顿。评估用户可以接受的响应时间和业务量，将目标简化为，希望GC暂停尽量控制在200ms以内，并且保证一定标准的吞吐量。
	- 掌握JVM和GC的状态，定位具体的问题，确定真的有GC调优的必要。具体有很多方法，比如，通过jstat等工具查看GC等相关状态，可以开启GC日志，或者利用操作系统提供的诊断工具等。例如，通过跟踪GC日志，就可以查找是不是GC在特定的时间发生了长时间的暂停，进而导致了响应响应不及时。
	- 需要思考，选择的GC类型是否符合应用的特征，如果是，具体的问题表现在哪里，是Minor GC过长，还是Mixed GC等出现异常停顿情况；如果不是，考虑切换到什么类型，如CMS和G1都是更侧重于低延迟的GC选项。
	- 通过分析确定具体调整的参数或者软硬件配置。
	- 验证是否达到调优的目标，如果达到目标，即可考虑结束调优；否则，重复完成分析、调整、验证这一过程。

### 关键点
- 能够真正快速定位和解决具体问题，还是需要对JVM和GC知识的掌握，以及实际调优经验的总结。经常性总结一些项目中的真实问题，结合JVM结构和GC知识，形成一种体系化的知识结构。
- 涉及具体的GC类型，JVM的实际表现要更加复杂。目前，G1已经成为新版JDK的默认选择，需要深入去理解这一GC算法。
- 因为G1 GC一直处在快速发展之中，理解它的过程中要侧重它的演进变化，尤其是行为和配置相关的变化。并且，同样是因为JVM的快速发展，即使是收集GC日志等方面也发生了较大改进。
- 从GC调优实践的角度，理解通用问题的调优思路和手段。

### G1 GC的内部结构和主要机制
- 从内存区域的角度，G1同样存在着年代的概念，但是与JVM的内存结构很不一样，其内部是类似棋盘状的一个个region组成。参考下图：
![g1gc内存结构划分](http://g1gc内存结构划分.png)
	- region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的region，这点可以从源码[heapRegionBounds.hpp](http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp)中看到。当然这个数字既可以手动调整，G1也会根据堆大小自动进行调整。
	- 在G1实现中，年代是个逻辑概念，具体体现在，一部分region是作为Eden，一部分作为Survivor，除了意料之中的Old region，G1会将超过region 50%大小的对象（在应用中，通常是byte或char数组）归类为Humongous对象，并放置在相应的region中。逻辑上，Humongous region算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代GC的复制算法。

- region设计的副作用
	- region大小和大对象很难保持一致，这会导致空间的浪费。如上图中有的区域是Humongous颜色，但是没有用名称标记，这是为了表示，特别大的对象时可能占用超过一个region的。而region太小又不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况。本质上，这也是JVM的bug，尽管解决办法也非常简单，直接设置较大的region大小，参数：`-XX:G1HeapRegionSize=<N>M`。例如设N为16则`-XX:G1HeapRegionSize=16M`。

- 从GC算法的角度，G1选择的是复合算法，可以简化理解为：
	- 在新生代，G1采用的仍然是并行的复制算法，所以同样会发生Stop-The-World的暂停。
	- 在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代GC时捎带进行，并且不是整体性的整理，而是增量进行的。

- 习惯上，人们喜欢把新生代GC(Young GC)叫做Minor GC，老年代GC叫做Major GC，区别于整体性的Full GC。但是现代GC中，这种概念已经不太准确，对于G1来说：
	- Minor GC仍然存在，虽然具体过程会有区别，会涉及Remembered Set等相关处理。
	- 老年代回收，则是依靠Mixed GC。并发标记结束后，JVM就有足够的信息进行垃圾收集，Mixed GC不仅同时会清理Eden，Survivor区域，而且还会清理部分Old区域。可以通过设置下面的参数，指定触发阈值，并且设定最多被包含在一次Mixed GC中的region比例。
	```
    -XX:G1MixedGCLiveThresholdPercent
    -XX:G1OldCSetRegionThresholdPercent
    ```

- 从G1内部运行的角度，下面的示意图描述了G1正常运行时的状态流转变化，当然，在发生逃逸失败等情况下，就会触发Full GC。
![g1gc状态流转图](http://g1gc状态流转图.png)

- G1相关概念非常多，有一个重点就是Remembered Set，用于记录和维护region之间对象的引用关系。为什么需要这么做呢？试想，新生代GC是复制算法，也就是说，类似对象从Eden或者Survivor到to区域的“移动”，其实是“复制“，本质上是一个新的对象。在这个过程中，需要必须保证老年代到新生代的跨区引用仍然有效。下面的示意图说明了相关设计。
![g1的rememberedset](http://g1的rememberedset.png)

- G1的很多开销都是源自Remembered Set，例如，它通常约占用Heap大小的20%或更高，这可是非常可观的比例。并且，进行对象复制的时候，因为需要扫描和更改Card Table的信息，这个速度影响了复制的速度，进而影响了暂停的时间。

- 描述G1的资料很多，这里就不赘述。如果想了解更多内部结果欧和算法等，可以参考一些具体的[介绍](https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All)，书籍方面推荐Charlie Hunt等撰写的《Java Performance Companion》。

### G行为变化
- 上一节提到了Humongous对象的分配和回收，这也是很多内存问题的来源，Humongous region作为老年代的一部分，通常认为它会在并发标记结束后才进行回收，但是在新版G1中Humongous对象回收采取了更加激进的策略。

- 众所周知，G1记录了老年代region间对象的引用，Humongous对象数量有限，所以能够快速的知道是否有老年代对象引用了它。如果没有，能够阻止它被回收的唯一可能，就是新生代是否有对象去引用了它，但是这个信息是可以在Young GC时就知道的，所以完全可以在Young GC中就进行Humongous对象的回收，不用像其他老年代对象那样，等待并发标记结束。

- 在垃圾收集过程中，G1会把新创建的字符串对象放入队列中，然后在Young GC之后，并发地（不会STW）将内部数据（char数组，JDK9 以后是byte数组）一致的字符串进行排重，也就是将其引用同一个数组。可以使用下面参数激活：`-XX:+useStringDeduplication`。值得注意的是，这种排重虽然可以节省不少内存空间，但这种并发操作会占用一些CPU资源，也会导致Young GC稍微变慢。

- 类型卸载是个长期困扰一些Java应用的问题，通常来讲，一个类只有当加载它的自定义类加载器被回收后，才能被卸载。元数据区替换了永久代之后有所改善，但还是可能出现问题。G1中只有发生了Full GC时才会进行类型卸载，但这显然不是开发者想要的。如果有需要，可以加上参数查看类型卸载：`-XX:+TraceClassUnloading`。但是，现代的G1已经不是如此了，8u40以后，G1增加并默认开启右边的选项：`-XX:+ClassUnloadingWithConcurrentMark` 也就是说，在并发标记阶段后，JVM即进行类型卸载。

- 众所周知，老年代的对象回收，基本要等待并发标记结束。这意味着，如果并发标记结束不及时，导致堆已满，但老年代空间还没完成回收，就会触发Full GC，所以触发并发标记的时机很重要。早期的G1调优中，通常会设置右边的参数 `-XX:InitiatingHeapOccupancyPercent` ，但是很难给出一个普适的数值，往往要根据实际运行结果调整。在JDK9之后的G1实现中，这种调整的需求会少很多，因为JVM只会将该参数作为初始值，会在运行时进行采样，获取统计数据，然后根据此动态调整并发标记启动时机。对应的JVM参数如下，默认已经开启：`-XX:+G1UseAdaptiveIHOP`

- 在现在的资料中，大多指出G1的Full GC是最差劲的单线程串行GC。其实，如果采用的是最新的JDK，会发现Full GC也是并行运行的，在通用场景中的表现还优于Parallel GC的Full GC实现。当然，新版JDK还有很多其他的改变，比如更快的Card Table 扫描等，它们并不带来行为的变化，基本不影响调优选择，所以不展开写。

### 调优建议
- 首先，建议尽量升级到较新的JDK版本，从上面介绍的改进就可以看到，很多人们常常讨论的问题，其实升级JDK就可以解决问题。
- 其次，掌握GC调优信息收集途径。掌握尽量全面、详细、准确的信息，是各种调优的基础，不仅仅是GC调优。以简单的打开GC日志为例，除了常用的两个选项：
```
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
```
还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项：`-XX:+PrintAdaptiveSizePolicy` 打印G1的Ergonomics相关信息。众所周知，GC内部的一些行为是适应性触发的，利用PrintAdaptiveSizePolicy，就可以知道为什么JVM做出了一些可能不被开发者期望的动作。例如，G1调优的一个基本建议就是避免进行大量的Humongous 对象分配，如果Ergonomics信息说明发生了这一点，那么就可以考虑要么增大堆的大小，要么直接将region大小提高。

	- 如果怀疑出现引用清理不及时的情况，可以打开右边的选项，掌握到底是哪里出现了堆积。`-XX:+PrintReferenceGC`
	- 此外，建议开启右边的选项进行并行引用处理：`-XX:+ParallelRefProcEnabled`
	- 值得注意的是，JDK9中JVM和GC日志机构进行了重构，其实前面提到的PrintGCDetails已经被标记为废弃，而PrintGCDateStamps已经被移出，指定它会导致JVM无法启动。可以使用右边的命令查询新的配置参数：`java -Xlog:help`

- 一些通用的实践
	- 如果发现Young GC非常耗时，这很可能是因为新生代太大了，可以考虑减少新生代的最小比例。 `-XX:G1NewSizePercent` 降低其最大值同样对降低Young GC延迟有帮助。`-XX:G1MaxNewSizePercent` 如果开发者直接为G1 设置较小的延迟目标值，也会起到减小新生代的效果但同时也会影响吞吐量。
	- 如果是Mixed GC延迟较长，例如：部分Old region会被包含进Mixed GC，减少一次处理的region个数，就是个直接的选择之一。上面提到过G1OldCSetRegionThresholdPercent控制其最大值，还可以利用右边的参数 `-XX:G1MixedGCCountTarget` 提高Mixed GC的个数，当前默认值是8，Mixed GC数量增多，意味着每次被包含的region减少。

- 值得注意的是，要避免过度调优，G1对大堆非常友好，其运行机制也需要浪费一定的空间，有时候稍微多给堆一些空间，比苛刻的调优更加实用。
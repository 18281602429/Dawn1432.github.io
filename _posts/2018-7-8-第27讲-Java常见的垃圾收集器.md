---
layout: post
title: Java常见的垃圾收集器
date: 2018-7-6
tags: Java核心技术36讲笔记
---

### Java常见的垃圾收集器有哪些
- 垃圾收集机制是Java的招牌能力，极大的提高了开发效率。如今，垃圾收集几乎成为了现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。
- 实际上，垃圾收集器（GC,Garbage Collector）是和具体JVM实现紧密相关的，不同厂商（IBM、Oracle），不同版本的JVM，提供的选择也不同。以下叙述以主流的Oracle JDK为准。
- Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集的过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下的JVM的默认选项。
	- 从年代的角度，通常将其老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：`-XX:+UseSerialGC`
- ParNew GC，很显然是个新生代GC实现，它实际是Serial GC的多线程版本，最常见的应用时配合老年代的CMS GC工作，下面是对应参数：`-XX:+UseConcMarkSweepGC -XX:+UseParNewGC`
- CMS(Concurrent Mark Sweep)GC，基于标记-清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是，CMS采用的标记-清除算法，存在着内存碎片化的问题，所以难以避免在长时间运行等情况下发生full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS会占用更多的CPU资源，并和用户线程争抢。
- Parallel GC，在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂很多，其特点是新生代和老年代GC都并行进行的，在常见的服务器环境中更加高效。开启的选项是：`-XX:+UseParallelGC`
	- Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM会自动进行适应性调整，例如下面参数：
	```
    -XX:MaxGCPauseMillis=value
    -XX:GCTimeRatio=N	// GC时间和用户时间比例=1/(N+1)
    ```

- G1 GC这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1 可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好的情况下的延时停顿，但是最差情况要好很多。
	- G1 GC仍然存在着年代的概念，但是其内存结构并不是简单的按年代进行条带式划分，而是类似棋盘的一个个region。Region之间是复制算法，但是整体上实际可看作是标记-整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候，G1的优势更加明显。
	- G1吞吐量和停顿表现都非常不错，并且仍然在不断的完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得深入掌握。


































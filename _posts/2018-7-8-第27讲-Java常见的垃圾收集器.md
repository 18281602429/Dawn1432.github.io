---
layout: post
title: Java常见的垃圾收集器
date: 2018-7-6
tags: Java核心技术36讲笔记
---

### Java常见的垃圾收集器有哪些
- 垃圾收集机制是Java的招牌能力，极大的提高了开发效率。如今，垃圾收集几乎成为了现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。
- 实际上，垃圾收集器（GC,Garbage Collector）是和具体JVM实现紧密相关的，不同厂商（IBM、Oracle），不同版本的JVM，提供的选择也不同。以下叙述以主流的Oracle JDK为准。
- Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集的过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下的JVM的默认选项。
	- 从年代的角度，通常将其老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC的对应JVM参数是：`-XX:+UseSerialGC`
- ParNew GC，很显然是个新生代GC实现，它实际是Serial GC的多线程版本，最常见的应用时配合老年代的CMS GC工作，下面是对应参数：`-XX:+UseConcMarkSweepGC -XX:+UseParNewGC`
- CMS(Concurrent Mark Sweep)GC，基于标记-清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是，CMS采用的标记-清除算法，存在着内存碎片化的问题，所以难以避免在长时间运行等情况下发生full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS会占用更多的CPU资源，并和用户线程争抢。
- Parallel GC，在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂很多，其特点是新生代和老年代GC都并行进行的，在常见的服务器环境中更加高效。开启的选项是：`-XX:+UseParallelGC`
	- Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM会自动进行适应性调整，例如下面参数：
	```
    -XX:MaxGCPauseMillis=value
    -XX:GCTimeRatio=N	// GC时间和用户时间比例=1/(N+1)
    ```

- G1 GC这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1 可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好的情况下的延时停顿，但是最差情况要好很多。
	- G1 GC仍然存在着年代的概念，但是其内存结构并不是简单的按年代进行条带式划分，而是类似棋盘的一个个region。Region之间是复制算法，但是整体上实际可看作是标记-整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候，G1的优势更加明显。
	- G1吞吐量和停顿表现都非常不错，并且仍然在不断的完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得深入掌握。

### 关键点
- 垃圾收集算法有哪些
- 如何判断一个对象是否可回收
- JDK发展过程中会逐渐新增的垃圾收集器有哪些

### 垃圾收集的原理和概念
- 自动垃圾收集的前提是清楚哪些内存时可以释放的。
- 主要就是两个方面：
	- 最主要的就是对象实例，都是存储在堆上的；
	- 还有就是方法区中元数据等信息，例如类型不再可用，卸载该Java类似乎很合理的。
- 对于对象实例收集，主要是两种基本算法，引用计数和可达性分析。
	- 引用计数算法，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。这是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。
	- Java使用的是可达性分析，Java的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，这种类型的垃圾收集通常叫作追踪性垃圾收集（[Tracing Garbage Collection](https://en.wikipedia.org/wiki/Tracing_garbage_collection)）。其原理简单说，就是将对象及其引用关系看作一个图，选定活动的对象为GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为GC Roots。

- 方法区无用元数据的回收比较复杂。一般来说初始化类加载器加载的类型是不会进行类卸载的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会出现OOM。在8u40以后的JDK中，下面的参数已经是默认的：`-XX:+ClassUnloadingWithConcurrentMark`

- 常见的垃圾收集算法，理解其各自的原理和优缺点，主要可以分为三类：
	- 复制（Copying）算法，我前面讲的新生代GC，基本都是基于复制算法。将或者的对象从from区域复制到to区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，就要提前预留内存空间，有一定的浪费；另外，对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间的对象引用关系，这个开销也不小，不管是内存占用或者时间开销。
	- 标记-清除（Mark-Sweep）算法，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现内存碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受。
	- 标记-整理（Mark-Compact），类似标记-清除，但是为了避免内存碎片化问题，它会在清理过程中，将对象移动，以确保移动后的对象占用连续的内存空间。
  值得注意的是，上面的这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。

### 垃圾收集过程的理解
- 在垃圾收集的过程中，对应到Eden、Survivor、Tenured等区域发生的变化实际上取决于具体的GC方式。
- 通常的垃圾收集流程如下：
	- Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用达到一定阈值时，触发minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到JVM选择的Survivor区域，而没有被引用的对象（黄色方块）则被回收。注意，给存活对象标记“数字1”，这是为了表明对象的存活时间。
	![minorGC](http://minorGC.png)
    - 经过一次Minor GC，Eden就会空闲下来，直到再次达到Minor GC触发条件，这时候，另外一个Survivor区域则会成为to区域，Eden区域的存活对象和From区域对象，都会被复制到to区域，并且存活的年龄计数会被加1。
    ![minorGC Twice](http://minorGC_Twice.png)
	- 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定的：`-XX:MaxTenuringThreshold=<N>`
	![tenured](http://tenured.png)
    - 后面就是老年代GC，具体取决于选择的GC选项，对应不同的算法。下面是简单标记-清理算法过程示意图，老年代中的无用对象被清除后，GC会将对象进行整理，以防止内存碎片化。
    ![老年代的标记-清理](http://老年代_标记_清理.png)
	- 通常会把老年代GC叫作Major GC，将对整个堆进行的清理叫作Full GC，但是这个也没有那么绝对，因为不同的老年代GC算法其实表现差异很大，例如CMS，“concurrent”就体现在清理工作是与工作线程一起并发运行的。

### GC的新发展
- GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如， JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。
- 即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。
- 比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。
- 如果有关注目前尚处于开发中的 JDK 11，会发现JDK 又增加了两种全新的 GC 方式，分别是：
	- [Epsilon GC](http://openjdk.java.net/jeps/318)，简单说就是个不做垃圾收集的 GC，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断 GC 本身产生了多大的开销，这就是其典型应用场景。
	- [ZGC](http://openjdk.java.net/jeps/333)，这是 Oracle 开源出来的一个超级 GC 实现，具备令人惊讶的扩展能力，比如支持 T bytes 级别的堆大小，并且保证绝大部分情况下，延迟都不会超过 10 ms。虽然目前还处于实验阶段，仅支持 Linux 64 位的平台，但其已经表现出的能力和潜力都非常令人期待。
  当然，其他厂商也提供了各种独具一格的 GC 实现，例如比较有名的低延迟 GC，[Zing](https://www.infoq.com/articles/azul_gc_in_detail)和[Shenandoah](https://wiki.openjdk.java.net/display/shenandoah/Main)等，有兴趣请参考链接。